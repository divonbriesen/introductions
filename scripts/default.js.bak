const form = document.getElementById("introForm");
const output = document.getElementById("output");

// sample courses used for initial state and reset
const SAMPLE_COURSES = [
  { dept: 'ITIS', number: '3135', name: 'Web Application Development I', reason: "I need this to graduate." },
  { dept: 'WEB', number: '115', name: 'Advanced Markup and Scripting', reason: "I'm majoring in full stack development." },
  { dept: 'ITSC', number: '1110', name: 'Computer Science Principles', reason: "I'm a CS 3rd year and need an easy A." },
  { dept: 'SCUBA', number: '1111', name: 'Underwater Basket Weaving', reason: "Doesn't everyone take this?" }
];

// sample full form data (alpaca-themed) used by Load Sample
const SAMPLE_FORM_DATA = {
  firstName: 'Joella',
  middleName: 'Fleur',
  lastName: 'Hoofer',
  preferredName: 'Jo',
  mascotDescriptor: 'Janky',
  mascot: 'Hippo',
  displayName: 'Joella "Jo" Hoofer',
  email: 'joella.hoofer@example.edu',
  acknowledgment: 'JH - 09/26/2025',
  imageUrl: 'https://picsum.photos/300?random=1',
  imageData: '',
  caption: 'Someplace I\'d rather be',
  personalStatement: "I'm a developer and educator who loves teaching people how to reason with code and algorithms. I enjoy hands-on projects, open-source collaboration, and coffee while debugging.",
  quoteText: 'Simplicity is the soul of efficiency.',
  quoteAuthor: 'Ada Lovelace',
  personalBackground: 'Grew up near the Andes; enjoys trekking, photography, and local cuisine.',
  professionalBackground: '5 years as a software engineer, 3 years as a curriculum developer for introductory CS courses.',
  academicBackground: 'BSc in Computer Science; ongoing study in human-centered computing.',
  funnyRemember: 'Once taught a class of llamas to debug a loop',
  otherNotes: "Prefers quinoa snacks and composes multilingual commit messages (12 languages)",
  computerPlatform: 'Laptop',
  computerOS: 'macOS',
  workLocation: 'Home office (City)',
  backupPlan: 'Use campus lab machine; phone hotspot and basic editor; keep code in cloud repo.'
};

// Rendering now uses DOM APIs (createElement/textContent) so explicit HTML-escaping helper is not needed.

// Load saved data from localStorage
window.addEventListener("load", () => {
  const savedData = localStorage.getItem("introData");
  // cache add button; the courses table will be queried where needed to avoid TDZ issues
  const addCourseBtn = document.getElementById('addCourseBtn');
  if (savedData) {
    const data = JSON.parse(savedData);
    for (const [key, value] of Object.entries(data)) {
      const field = form.elements[key];
      if (field) field.value = value;
    }
    // If saved data has a legacy combined `mascot` value, try to split into descriptor + mascot
    if (data.mascot && form.elements['mascotDescriptor'] && form.elements['mascot']) {
      // only split if descriptor field is empty (avoid overwriting explicit values)
      const descField = form.elements['mascotDescriptor'];
      const mascField = form.elements['mascot'];
      if ((!descField.value || descField.value.trim() === '') && mascField.value && mascField.value.trim().indexOf(' ') !== -1) {
        const parts = mascField.value.trim().split(/\s+/);
        const last = parts.pop();
        descField.value = parts.join(' ');
        mascField.value = last;
      }
    }
    // populate courses into the table first, then render preview
    if (data.courses && Array.isArray(data.courses)) {
      populateCoursesFromData(data.courses);
    }
    // recompute and set readonly displayName to include middle initial and update the data object
    try {
      const fd = new FormData(form);
      const dn = computeDisplayName(fd);
      if (form.elements['displayName']) form.elements['displayName'].value = dn;
      data.displayName = dn;
    } catch (e) {}
    renderIntro(data);
  } else {
    // no saved data: auto-save current (prefilled) form values
    const initialData = Object.fromEntries(new FormData(form).entries());
    // provide sample courses for initial state
    initialData.courses = SAMPLE_COURSES.slice();
  // persist and render the initial sample data
  // ensure readonly displayName matches the computed format
  try { const fd0 = new FormData(form); initialData.displayName = computeDisplayName(fd0); if (form.elements['displayName']) form.elements['displayName'].value = initialData.displayName; } catch(e) {}
  localStorage.setItem('introData', JSON.stringify(initialData));
    // ensure fields reflect initialData
    for (const [key, value] of Object.entries(initialData)) {
      const field = form.elements[key];
      if (field) field.value = value;
    }
    // populate initial sample courses then render
    if (initialData.courses && Array.isArray(initialData.courses)) populateCoursesFromData(initialData.courses);
    renderIntro(initialData);
  }

  // wire reset (clear) and load sample buttons
  const resetBtn = document.getElementById('resetBtn');
  const loadSampleBtn = document.getElementById('loadSampleBtn');
  // image file input and hidden data field
  const imageFileInput = document.getElementById('imageFile');
  const imageDataField = document.getElementById('imageData');
  // top duplicated buttons (subtle/texty)
  const submitTopBtn = document.getElementById('submitTopBtn');
  const loadSampleTopBtn = document.getElementById('loadSampleTopBtn');
  const resetTopBtn = document.getElementById('resetTopBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      // If the current form matches the shipped SAMPLE data (form + courses), treat this as "clear sample" and skip the warning.
      const isSample = (function() {
        try {
          const keys = ['firstName','middleName','lastName','preferredName','mascotDescriptor','mascot','caption'];
          for (const k of keys) {
            const el = form.elements[k];
            const v = el ? (el.value || '').trim() : '';
            const sv = (SAMPLE_FORM_DATA[k] || '').toString().trim();
            if (v !== sv) return false;
          }
          // compare courses
          const table = document.getElementById('coursesTable');
          const rows = table ? Array.from(table.querySelectorAll('.course-row')) : [];
          if (rows.length !== SAMPLE_COURSES.length) return false;
          for (let i = 0; i < rows.length; i++) {
            const r = rows[i];
            const s = SAMPLE_COURSES[i] || {};
            const dept = (r.querySelector('input[name="course_dept"]') || {}).value || '';
            const number = (r.querySelector('input[name="course_number"]') || {}).value || '';
            const name = (r.querySelector('input[name="course_name"]') || {}).value || '';
            const reason = (r.querySelector('input[name="course_reason"]') || {}).value || '';
            if (dept.trim() !== (s.dept || '').toString().trim() || number.trim() !== (s.number || '').toString().trim() || name.trim() !== (s.name || '').toString().trim() || reason.trim() !== (s.reason || '').toString().trim()) return false;
          }
          return true;
        } catch (e) { return false; }
      })();

      if (!isSample) {
        // warn user before clearing persisted data
        const ok = window.confirm('Warning: this will clear the form and permanently delete the saved data stored in your browser. Continue?');
        if (!ok) return;
      }
      // remove persisted data
      localStorage.removeItem('introData');
      // clear preview
      if (output) output.innerHTML = '';
      // clear all form controls so fields become empty (form.reset() would revert to HTML defaults)
      Array.from(form.querySelectorAll('input,textarea,select')).forEach(el => {
        const tag = el.tagName.toLowerCase();
        const type = (el.type || '').toLowerCase();
        if (type === 'checkbox' || type === 'radio') {
          el.checked = false;
        } else if (tag === 'select') {
          try { el.selectedIndex = -1; } catch (e) { /* ignore */ }
        } else {
          el.value = '';
        }
      });
      // clear any generated displayName explicitly
      if (form.elements['displayName']) form.elements['displayName'].value = '';
      // clear courses table rows
      const table = document.getElementById('coursesTable');
      if (table) Array.from(table.querySelectorAll('.course-row')).forEach(r => r.remove());
      reindexCourseRows();
      // focus first field for convenience
      const first = form.querySelector('input[name="firstName"]'); if (first) first.focus();
    });
  }
  if (loadSampleBtn) {
    loadSampleBtn.addEventListener('click', () => {
      // populate form fields from SAMPLE_FORM_DATA
      for (const [k, v] of Object.entries(SAMPLE_FORM_DATA)) {
        const f = form.elements[k]; if (f) f.value = v;
      }
      // clear any previously uploaded image data when loading the sample
      if (imageDataField) imageDataField.value = '';
      if (imageFileInput) imageFileInput.value = '';
      // populate courses
      const table = document.getElementById('coursesTable');
      if (table) {
        Array.from(table.querySelectorAll('.course-row')).forEach(r => r.remove());
        SAMPLE_COURSES.forEach(c => addCourseRow(c));
      }
      // persist combined data
      const data = Object.fromEntries(new FormData(form).entries());
      data.courses = SAMPLE_COURSES.slice();
  // preserve mascot descriptor and mascot separately (keep mascot e.g. 'Hippo' and descriptor 'Janky')
  const desc = (form.elements['mascotDescriptor'] || {}).value || '';
  const masc = (form.elements['mascot'] || {}).value || '';
  if (masc.trim()) data.mascot = masc.trim();
  if (desc.trim()) data.mascotDescriptor = desc.trim();
      // recompute and set displayName with middle initial
      try { const fd1 = new FormData(form); data.displayName = computeDisplayName(fd1); if (form.elements['displayName']) form.elements['displayName'].value = data.displayName; } catch(e) {}
      localStorage.setItem('introData', JSON.stringify(data));
      renderIntro(data);
    });
  }

  // (Label colons are now included in the static HTML; runtime helper removed.)

  // handle image file uploads: read as DataURL and store in hidden imageData field
  if (imageFileInput) {
    const imagePreview = document.getElementById('imagePreview');
    const clearImageBtn = document.getElementById('clearImageBtn');
  const imageErrorEl = document.getElementById('imageError');
  const imageSpinner = document.getElementById('imageSpinner');
  const imageStatus = document.getElementById('imageStatus');
    const MAX_IMAGE_BYTES = 400 * 1024; // 400 KB
    const DOWNSCALE_THRESHOLD = 200 * 1024; // start compressing if larger than 200 KB

    // Helper: compress / downscale an image File to a Data URL under maxBytes when possible.
    // - honors EXIF orientation
    // - attempts WebP first (if supported) then JPEG
    // - uses binary-search on quality for tighter size targeting
    function compressFileForLocalStorage(file, maxBytes, maxWidth) {
      // parse EXIF orientation from a JPEG ArrayBuffer (returns 1-8 or -1/0 when unknown)
      function getOrientationFromArrayBuffer(arrayBuffer) {
        try {
          const view = new DataView(arrayBuffer);
          if (view.getUint16(0) !== 0xFFD8) return -1; // not a JPEG
          let offset = 2;
          const length = view.byteLength;
          while (offset < length) {
            if (view.getUint16(offset) === 0xFFE1) {
              const exifLength = view.getUint16(offset + 2);
              const exifStart = offset + 4;
              // check for 'Exif\0\0'
              if (view.getUint32(exifStart) !== 0x45786966) break;
              const little = view.getUint16(exifStart + 6) === 0x4949;
              const tags = view.getUint16(exifStart + 10, little);
              let tagOffset = exifStart + 12;
              for (let i = 0; i < tags; i++) {
                const tag = view.getUint16(tagOffset, little);
                if (tag === 0x0112) {
                  const orient = view.getUint16(tagOffset + 8, little);
                  return orient;
                }
                tagOffset += 12;
              }
              break;
            }
            offset += 2 + view.getUint16(offset + 2);
          }
        } catch (e) {
          return -1;
        }
        return -1;
      }

      function applyOrientationToCanvas(ctx, width, height, orientation) {
        switch (orientation) {
          case 2: ctx.translate(width, 0); ctx.scale(-1, 1); break; // horizontal flip
          case 3: ctx.translate(width, height); ctx.rotate(Math.PI); break; // 180
          case 4: ctx.translate(0, height); ctx.scale(1, -1); break; // vertical flip
          case 5: ctx.rotate(0.5 * Math.PI); ctx.scale(1, -1); break; // transpose
          case 6: ctx.rotate(0.5 * Math.PI); ctx.translate(0, -height); break; // rotate 90
          case 7: ctx.rotate(0.5 * Math.PI); ctx.translate(width, -height); ctx.scale(-1, 1); break; // transverse
          case 8: ctx.rotate(-0.5 * Math.PI); ctx.translate(-width, 0); break; // rotate 270
          default: break; // 1 or unknown: no transform
        }
      }

      // try to encode canvas to dataURL using binary-search quality; return null if can't get under maxBytes
      function encodeCanvasBinarySearch(canvas, mimeType, maxBytes) {
        return new Promise((resolve) => {
          let low = 0.5, high = 0.95;
          let best = null;
          let bestSize = Infinity;
          let attempts = 0;
          function attempt() {
            const q = (low + high) / 2;
            let dataUrl;
            try {
              dataUrl = canvas.toDataURL(mimeType, q);
            } catch (err) {
              return resolve(null);
            }
            const size = atob(dataUrl.split(',')[1]).length;
            if (size <= maxBytes) {
              best = dataUrl; bestSize = size; low = q; // try higher quality
            } else {
              high = q; // lower quality
            }
            attempts++;
            if (attempts < 8 && (high - low) > 0.01) return setTimeout(attempt, 0);
            return resolve(best);
          }
          attempt();
        });
      }

      return new Promise((resolve, reject) => {
        // read as ArrayBuffer to get EXIF orientation, and use object URL for image source
        const arrReader = new FileReader();
        arrReader.onload = function(ev) {
          const arrayBuffer = ev.target.result;
          const orientation = getOrientationFromArrayBuffer(arrayBuffer) || -1;
          const blobUrl = URL.createObjectURL(file);
          const img = new Image();
          img.onload = async function() {
            try {
              let iw = img.width, ih = img.height;
              let targetW = iw, targetH = ih;
              const rotated = orientation === 5 || orientation === 6 || orientation === 7 || orientation === 8;
              const maxW = maxWidth || iw;
              if ((rotated ? ih : iw) > maxW) {
                // scale keeping aspect ratio
                const scale = maxW / (rotated ? ih : iw);
                targetW = Math.round(iw * scale);
                targetH = Math.round(ih * scale);
              }
              const canvas = document.createElement('canvas');
              // if rotated 90/270, swap canvas dimensions
              if (orientation === 5 || orientation === 6 || orientation === 7 || orientation === 8) {
                canvas.width = targetH; canvas.height = targetW;
              } else {
                canvas.width = targetW; canvas.height = targetH;
              }
              const ctx = canvas.getContext('2d');
              // apply orientation transforms
              ctx.save();
              // translate/rotate according to orientation before drawing
              switch (orientation) {
                case 2: ctx.translate(canvas.width, 0); ctx.scale(-1, 1); break;
                case 3: ctx.translate(canvas.width, canvas.height); ctx.rotate(Math.PI); break;
                case 4: ctx.translate(0, canvas.height); ctx.scale(1, -1); break;
                case 5: ctx.rotate(0.5 * Math.PI); ctx.scale(1, -1); break;
                case 6: ctx.rotate(0.5 * Math.PI); ctx.translate(0, -canvas.height); break;
                case 7: ctx.rotate(0.5 * Math.PI); ctx.translate(canvas.width, -canvas.height); ctx.scale(-1, 1); break;
                case 8: ctx.rotate(-0.5 * Math.PI); ctx.translate(-canvas.width, 0); break;
                default: break;
              }
              // draw the image scaled into canvas
              // compute draw dimensions after transforms
              if (orientation === 5 || orientation === 6 || orientation === 7 || orientation === 8) {
                ctx.drawImage(img, 0, 0, targetW, targetH);
              } else {
                ctx.drawImage(img, 0, 0, targetW, targetH);
              }
              ctx.restore();

              // First try WebP then JPEG
              const tryFormats = ['image/webp', 'image/jpeg'];
              for (const fmt of tryFormats) {
                // quick test for webp support: attempt toDataURL in try/catch
                try {
                  const dataUrlTest = canvas.toDataURL(fmt, 0.9);
                  // try binary-search quality to find acceptable size
                  const encoded = await encodeCanvasBinarySearch(canvas, fmt, maxBytes);
                  if (encoded) {
                    URL.revokeObjectURL(blobUrl);
                    return resolve(encoded);
                  }
                } catch (err) {
                  // format not supported or failed; try next
                  continue;
                }
              }
              // if none produced acceptable size, resolve null
              URL.revokeObjectURL(blobUrl);
              return resolve(null);
            } catch (ex) {
              URL.revokeObjectURL(blobUrl);
              return reject(ex);
            }
          };
          img.onerror = function() { URL.revokeObjectURL(blobUrl); reject(new Error('Image load failed')); };
          img.src = blobUrl;
        };
        arrReader.onerror = function() { reject(new Error('File read failed')); };
        arrReader.readAsArrayBuffer(file);
      });
    }

    imageFileInput.addEventListener('change', (e) => {
      imageErrorEl && (imageErrorEl.style.display = 'none');
      const file = (e.target.files && e.target.files[0]) ? e.target.files[0] : null;
      if (!file) {
        if (imageDataField) imageDataField.value = '';
        if (imagePreview) { imagePreview.src = ''; imagePreview.style.display = 'none'; }
        if (clearImageBtn) clearImageBtn.style.display = 'none';
        // trigger autosave to persist cleared state
        form.dispatchEvent(new Event('input', { bubbles: true }));
        return;
      }
      // If file is moderately large, attempt to compress / downscale before saving
      if (file.size > MAX_IMAGE_BYTES) {
        // If it's too large even before trying, attempt compression if it's over the downscale threshold
        if (file.size > DOWNSCALE_THRESHOLD) {
          if (imageSpinner) imageSpinner.style.display = 'inline-block';
          if (imageStatus) imageStatus.textContent = 'Compressing image…';
          compressFileForLocalStorage(file, MAX_IMAGE_BYTES, 1024).then((compressedDataUrl) => {
            // check final size
            if (!compressedDataUrl) {
              if (imageSpinner) imageSpinner.style.display = 'none';
              if (imageStatus) imageStatus.textContent = '';
              if (imageErrorEl) { imageErrorEl.textContent = `Image could not be reduced below ${Math.round(MAX_IMAGE_BYTES/1024)} KB. Please choose a smaller image.`; imageErrorEl.style.display = 'block'; }
              imageFileInput.value = '';
              return;
            }
            const sizeApprox = atob(compressedDataUrl.split(',')[1]).length;
            if (sizeApprox > MAX_IMAGE_BYTES) {
              if (imageSpinner) imageSpinner.style.display = 'none';
              if (imageErrorEl) { imageErrorEl.textContent = `Image could not be reduced below ${Math.round(MAX_IMAGE_BYTES/1024)} KB. Please choose a smaller image.`; imageErrorEl.style.display = 'block'; }
              imageFileInput.value = '';
              return;
            }
            // use compressed
            if (imageDataField) imageDataField.value = compressedDataUrl;
            if (imagePreview) { imagePreview.src = compressedDataUrl; imagePreview.style.display = 'inline-block'; }
            if (clearImageBtn) clearImageBtn.style.display = 'inline-block';
            const data = Object.fromEntries(new FormData(form).entries());
            data.courses = (data.courses && Array.isArray(data.courses)) ? data.courses : undefined;
            localStorage.setItem('introData', JSON.stringify(data));
            if (imageSpinner) imageSpinner.style.display = 'none';
            if (imageStatus) imageStatus.textContent = 'Image ready.';
            setTimeout(() => { if (imageStatus) imageStatus.textContent = ''; }, 1200);
            renderIntro(data);
          }).catch((err) => {
            if (imageSpinner) imageSpinner.style.display = 'none';
            if (imageStatus) imageStatus.textContent = '';
            if (imageErrorEl) { imageErrorEl.textContent = 'Could not process image. Try a different file.'; imageErrorEl.style.display = 'block'; }
            imageFileInput.value = '';
          });
          return;
        }
        // otherwise reject large file immediately
        if (imageErrorEl) { imageErrorEl.textContent = `Image is too large (${Math.round(file.size/1024)} KB). Max ${Math.round(MAX_IMAGE_BYTES/1024)} KB.`; imageErrorEl.style.display = 'block'; }
        imageFileInput.value = '';
        return;
      }
      // small enough: read as DataURL and store
      const reader = new FileReader();
      reader.onload = function(evt) {
        const dataUrl = evt.target.result;
        if (imageDataField) imageDataField.value = dataUrl;
        // show preview
        if (imagePreview) { imagePreview.src = dataUrl; imagePreview.style.display = 'inline-block'; }
        if (clearImageBtn) clearImageBtn.style.display = 'inline-block';
        // persist immediately
        const data = Object.fromEntries(new FormData(form).entries());
        data.courses = (data.courses && Array.isArray(data.courses)) ? data.courses : undefined;
        localStorage.setItem('introData', JSON.stringify(data));
        renderIntro(data);
      };
      reader.readAsDataURL(file);
    });

    // Clear uploaded image handler
    if (clearImageBtn) {
      clearImageBtn.addEventListener('click', () => {
        if (imageFileInput) imageFileInput.value = '';
        if (imageDataField) imageDataField.value = '';
        if (imagePreview) { imagePreview.src = ''; imagePreview.style.display = 'none'; }
        clearImageBtn.style.display = 'none';
        // persist cleared state
        const data = Object.fromEntries(new FormData(form).entries());
        localStorage.setItem('introData', JSON.stringify(data));
        renderIntro(data);
      });
    }
  }

  // wire top buttons to existing handlers (delegation)
  if (submitTopBtn) submitTopBtn.addEventListener('click', (e) => { e.preventDefault(); form.requestSubmit ? form.requestSubmit() : form.submit(); });
  if (loadSampleTopBtn && loadSampleBtn) loadSampleTopBtn.addEventListener('click', (e) => { e.preventDefault(); loadSampleBtn.click(); });
  if (resetTopBtn && resetBtn) resetTopBtn.addEventListener('click', (e) => { e.preventDefault(); resetBtn.click(); });
  // bottom text links: prevent default and call handlers
  const submitBtn = document.getElementById('submitBtn');
  const loadSampleBtnLink = document.getElementById('loadSampleBtn');
  const resetBtnLink = document.getElementById('resetBtn');
  if (submitBtn) submitBtn.addEventListener('click', (e) => { e.preventDefault(); form.requestSubmit ? form.requestSubmit() : form.submit(); });
  if (loadSampleBtnLink && loadSampleBtn) loadSampleBtnLink.addEventListener('click', (e) => { e.preventDefault(); loadSampleBtn.click(); });
  if (resetBtnLink && resetBtn) resetBtnLink.addEventListener('click', (e) => { e.preventDefault(); resetBtn.click(); });

  // Courses: helper to add/remove rows
  function addCourseRow(course = {}, index = null) {
    const row = document.createElement('div');
    row.className = 'course-row';
    const idx = document.createElement('div'); idx.className = 'col-num'; idx.textContent = '';
    const dept = document.createElement('input'); dept.name = 'course_dept'; dept.placeholder = 'e.g., CS'; dept.value = course.dept || '';
    const number = document.createElement('input'); number.name = 'course_number'; number.placeholder = 'e.g., 101'; number.value = course.number || '';
    const name = document.createElement('input'); name.name = 'course_name'; name.placeholder = 'Course title'; name.value = course.name || '';
    const reason = document.createElement('input'); reason.name = 'course_reason'; reason.placeholder = 'Reason for taking'; reason.value = course.reason || '';
  const actions = document.createElement('div'); actions.className = 'col-actions';
  // Move Up / Move Down buttons for keyboard accessibility
  const moveUpBtn = document.createElement('button'); moveUpBtn.type = 'button'; moveUpBtn.className = 'move-up'; moveUpBtn.title = 'Move course up'; moveUpBtn.setAttribute('aria-label', 'Move course up');
  moveUpBtn.innerHTML = '<svg class="icon-action" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 19V6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 12l7-7 7 7" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
  moveUpBtn.addEventListener('click', () => {
    const prev = row.previousElementSibling;
    const table = document.getElementById('coursesTable');
    if (prev && prev.classList.contains('course-row')) {
      table.insertBefore(row, prev);
    } else {
      // if there is no previous row (this is the first), move it to the end
      table.appendChild(row);
    }
    reindexCourseRows();
    // keep focus on the first input
    const f = row.querySelector('input[name="course_dept"]') || row.querySelector('input'); if (f) f.focus();
  });
  const addBelowBtn = document.createElement('button');
  addBelowBtn.type = 'button';
  addBelowBtn.className = 'add-below-btn';
  addBelowBtn.title = 'Add course below';
  addBelowBtn.setAttribute('aria-label', 'Add course below');
  addBelowBtn.innerHTML = '<svg class="icon-action" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M12 5v14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M5 12h14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
  addBelowBtn.addEventListener('click', () => {
    const table = document.getElementById('coursesTable');
    // create new row (appends to end), then move it to just after this row
    const newRow = addCourseRow({});
    const next = row.nextElementSibling;
    if (next && next.classList.contains('course-row')) {
      table.insertBefore(newRow, next);
    }
    reindexCourseRows();
    const f = newRow.querySelector('input[name="course_dept"]') || newRow.querySelector('input'); if (f) f.focus();
  });
  const removeBtn = document.createElement('button');
  removeBtn.type = 'button';
  removeBtn.className = 'remove-btn';
  removeBtn.title = 'Remove course';
  removeBtn.setAttribute('aria-label', 'Remove course');
  removeBtn.innerHTML = '<svg class="icon-action" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/><path d="M6 18L18 6" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
  removeBtn.addEventListener('click', () => { row.remove(); reindexCourseRows(); });
  actions.appendChild(moveUpBtn);
  actions.appendChild(addBelowBtn);
  actions.appendChild(removeBtn);
  // per-row inline error message
  const rowError = document.createElement('div'); rowError.className = 'row-error'; rowError.setAttribute('aria-live', 'polite'); rowError.style.display = 'none';
  actions.appendChild(rowError);
    row.appendChild(idx);
    const wrapDept = document.createElement('div'); wrapDept.className = 'col-dept'; wrapDept.appendChild(dept);
    const wrapNumber = document.createElement('div'); wrapNumber.className = 'col-number'; wrapNumber.appendChild(number);
    const wrapName = document.createElement('div'); wrapName.className = 'col-name'; wrapName.appendChild(name);
    const wrapReason = document.createElement('div'); wrapReason.className = 'col-reason'; wrapReason.appendChild(reason);
    row.appendChild(wrapDept);
    row.appendChild(wrapNumber);
    row.appendChild(wrapName);
    row.appendChild(wrapReason);
    row.appendChild(actions);

    // make row draggable
    row.draggable = true;
    row.addEventListener('dragstart', (e) => {
      row.classList.add('draggable');
      draggingRow = row;
      e.dataTransfer.effectAllowed = 'move';
    });
    row.addEventListener('dragend', () => {
      row.classList.remove('draggable');
      draggingRow = null;
      // remove any leftover drag-over classes
      const table = document.getElementById('coursesTable');
      Array.from(table.querySelectorAll('.course-row')).forEach(r => r.classList.remove('drag-over'));
    });

    row.addEventListener('dragover', (e) => { e.preventDefault(); row.classList.add('drag-over'); });
    row.addEventListener('dragleave', () => { row.classList.remove('drag-over'); });
    row.addEventListener('drop', (e) => {
      e.preventDefault();
      row.classList.remove('drag-over');
      if (!draggingRow || draggingRow === row) return;
      // insert draggingRow before this row
      const table = document.getElementById('coursesTable');
      table.insertBefore(draggingRow, row);
      reindexCourseRows();
    });

    // Basic touch fallback for reordering on touch devices
    let touchStartY = 0;
    row.addEventListener('touchstart', (e) => {
      touchStartY = e.touches[0].clientY;
      row.classList.add('draggable');
    }, { passive: true });
    row.addEventListener('touchmove', (e) => {
      const y = e.touches[0].clientY;
      const dy = y - touchStartY;
      // small translate for feedback
      row.style.transform = `translateY(${dy}px)`;
    }, { passive: true });
    row.addEventListener('touchend', (e) => {
  row.style.transform = '';
  row.classList.remove('draggable');
      // simple heuristic: if moved upwards enough, move before previous, if downwards enough, move after next
      const endY = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : touchStartY;
      const delta = endY - touchStartY;
      const threshold = 30; // pixels
      if (delta < -threshold) {
        const prev = row.previousElementSibling;
        const table = document.getElementById('coursesTable');
        if (prev && prev.classList.contains('course-row')) {
          table.insertBefore(row, prev);
          reindexCourseRows();
        }
      } else if (delta > threshold) {
        const next = row.nextElementSibling;
        const table = document.getElementById('coursesTable');
        if (next && next.classList.contains('course-row')) {
          table.insertBefore(next, row);
          reindexCourseRows();
        }
      }
    });

    const table = document.getElementById('coursesTable');
    table.appendChild(row);
    reindexCourseRows();
    return row;
  }

  function reindexCourseRows() {
    const table = document.getElementById('coursesTable');
    const rows = Array.from(table.querySelectorAll('.course-row'));
    rows.forEach((r, i) => {
      const num = r.querySelector('.col-num');
      if (num) num.textContent = String(i + 1);
      // move-up now wraps to bottom, so keep it enabled; remove move-down (no longer used)
      const up = r.querySelector('button.move-up');
      if (up) up.disabled = false;
    });
    const count = rows.length;
    const hidden = document.getElementById('coursesCount');
    if (hidden) hidden.value = String(count);
  }

  function populateCoursesFromData(courses) {
    const table = document.getElementById('coursesTable');
    if (!table) return;
    // remove existing rows
    Array.from(table.querySelectorAll('.course-row')).forEach(r => r.remove());
    courses.forEach(c => addCourseRow(c));
  }

  if (addCourseBtn) addCourseBtn.addEventListener('click', () => addCourseRow({}));

  // dragging state for DnD
  let draggingRow = null;

  // Setup copy buttons (JSON / HTML)
  const copyJsonBtn = document.getElementById('copyJsonBtn');
  const copyHtmlBtn = document.getElementById('copyHtmlBtn');
  const jsonStatus = document.getElementById('copyJsonStatus');
  const htmlStatus = document.getElementById('copyHtmlStatus');
  if (copyJsonBtn) copyJsonBtn.addEventListener('click', () => {
    const jsonArea = document.getElementById('jsonOutput');
    if (!jsonArea) return;
    navigator.clipboard.writeText(jsonArea.value).then(() => {
      if (jsonStatus) { jsonStatus.textContent = 'Copied'; setTimeout(() => jsonStatus.textContent = '', 1500); }
      // swap icon to check
      swapIconToCheck(copyJsonBtn);
    }).catch(() => { if (jsonStatus) jsonStatus.textContent = 'Copy failed'; });
  });
  if (copyHtmlBtn) copyHtmlBtn.addEventListener('click', () => {
    const htmlArea = document.getElementById('htmlOutput');
    if (!htmlArea) return;
    navigator.clipboard.writeText(htmlArea.value).then(() => {
      if (htmlStatus) { htmlStatus.textContent = 'Copied'; setTimeout(() => htmlStatus.textContent = '', 1500); }
      swapIconToCheck(copyHtmlBtn);
    }).catch(() => { if (htmlStatus) htmlStatus.textContent = 'Copy failed'; });
  });

  // Helper to swap the inline SVG in a button to a checkmark briefly
  function swapIconToCheck(button) {
    if (!button) return;
    const original = button.innerHTML;
    // simple checkmark SVG
    const check = '<svg class="icon-check" width="18" height="18" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><path d="M20 6L9 17l-5-5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>';
    button.innerHTML = check;
    // add class to trigger CSS animation/color change
    button.classList.add('copied');
    setTimeout(() => { button.classList.remove('copied'); button.innerHTML = original; }, 1500);
  }

  // validation UI attached near add button
  const coursesValidation = document.getElementById('coursesValidation') || (() => {
    const d = document.createElement('div'); d.id = 'coursesValidation'; d.style.color = 'darkred'; d.style.marginTop = '0.5rem';
    const addBtnContainer = document.getElementById('addCourseBtn')?.parentElement;
    if (addBtnContainer) addBtnContainer.appendChild(d);
    return d;
  })();

  function validateCourses() {
    const table = document.getElementById('coursesTable');
    const rows = table ? table.querySelectorAll('.course-row') : [];
    const problems = [];
    let anyInvalid = false;
    rows.forEach((r, i) => {
      const dept = (r.querySelector('input[name="course_dept"]') || {}).value?.trim() || '';
      const number = (r.querySelector('input[name="course_number"]') || {}).value?.trim() || '';
      const errEl = r.querySelector('.row-error');
      if (errEl) { errEl.textContent = ''; errEl.style.display = 'none'; }
      r.removeAttribute('data-invalid');
      if (!dept || !number) {
        const msg = `Department and Course # required`;
        problems.push(`Row ${i+1}: ${msg}`);
        if (errEl) { errEl.textContent = msg; errEl.style.display = 'block'; }
        r.dataset.invalid = 'true';
        anyInvalid = true;
      }
    });
    if (problems.length) {
      coursesValidation.textContent = problems.join('; ');
    } else {
      coursesValidation.textContent = '';
    }
    return !anyInvalid;
  }

  // helper to compute displayName: First "Preferred" M. Last ~ Mascot
  function computeDisplayName(formData) {
    const first = (formData.get('firstName') || '').toString().trim();
    const middle = (formData.get('middleName') || '').toString().trim();
    const last = (formData.get('lastName') || '').toString().trim();
    const preferred = (formData.get('preferredName') || '').toString().trim();
    const mascotDesc = (formData.get('mascotDescriptor') || '').toString().trim();
    const mascot = (formData.get('mascot') || '').toString().trim();
    const middleInitial = middle ? (middle[0] + '.') : '';
    // Desired format: First M. "Nickname" Last
    const nicknamePart = preferred ? `"${preferred}"` : '';
    const parts = [first, middleInitial, nicknamePart, last].filter(Boolean);
    const namePart = parts.join(' ');
    const combinedMascot = mascotDesc && mascot ? `${mascotDesc} ${mascot}` : (mascotDesc || mascot);
    const dividerRaw = (formData.get('mascotDivider') || '').toString();
    const divider = dividerRaw.trim();
    if (combinedMascot) {
      const sep = divider ? ` ${divider} ` : ' ~ ';
      return `${namePart}${sep}${combinedMascot}`;
    }
    return namePart;
  }

  // autosave on input (debounced) and update computed displayName
  let saveTimer = null;
  form.addEventListener('input', () => {
    // compute the displayName and set readonly field
    const fd = new FormData(form);
    const computed = computeDisplayName(fd);
    const displayField = form.elements['displayName'];
    if (displayField) displayField.value = computed;

    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(() => {
      // validate courses (show per-row errors) but still save drafts
      if (typeof validateCourses === 'function') validateCourses();
      const data = Object.fromEntries(new FormData(form).entries());
      // combine mascotDescriptor + mascot into a single `mascot` string for backward-compatibility
      (function combineMascot(d) {
        const desc = (form.elements['mascotDescriptor'] || {}).value || '';
        const masc = (form.elements['mascot'] || {}).value || '';
        // preserve descriptor and mascot as separate fields so mascot stays just the mascot (e.g., "Hippo")
        if (masc.trim()) d.mascot = masc.trim();
        if (desc.trim()) d.mascotDescriptor = desc.trim();
      })(data);
      // collect courses into an array
      const courses = [];
      const coursesTableEl = document.getElementById('coursesTable');
      if (coursesTableEl) {
        const rows = coursesTableEl.querySelectorAll('.course-row');
        rows.forEach(r => {
          const dept = (r.querySelector('input[name="course_dept"]') || {}).value || '';
          const number = (r.querySelector('input[name="course_number"]') || {}).value || '';
          const name = (r.querySelector('input[name="course_name"]') || {}).value || '';
          const reason = (r.querySelector('input[name="course_reason"]') || {}).value || '';
          if (dept || number || name || reason) courses.push({dept, number, name, reason});
        });
      }
      if (courses.length) data.courses = courses;
      // ensure stored data includes computed displayName
      data.displayName = computed;
      localStorage.setItem('introData', JSON.stringify(data));
      renderIntro(data);
    }, 500);
  });
});

form.addEventListener("submit", function(e) {
  e.preventDefault();
  if (typeof validateCourses === 'function' && !validateCourses()) return;
  const data = Object.fromEntries(new FormData(form).entries());
  // combine mascotDescriptor + mascot into `mascot` for saved data
  (function combineMascot(d) {
    const desc = (form.elements['mascotDescriptor'] || {}).value || '';
    const masc = (form.elements['mascot'] || {}).value || '';
    if (masc.trim()) d.mascot = masc.trim();
    if (desc.trim()) d.mascotDescriptor = desc.trim();
  })(data);
  // gather courses similarly for submit
  const courses = [];
  const coursesTableEl = document.getElementById('coursesTable');
  if (coursesTableEl) {
    const rows = coursesTableEl.querySelectorAll('.course-row');
    rows.forEach(r => {
      const dept = (r.querySelector('input[name="course_dept"]') || {}).value || '';
      const number = (r.querySelector('input[name="course_number"]') || {}).value || '';
      const name = (r.querySelector('input[name="course_name"]') || {}).value || '';
      const reason = (r.querySelector('input[name="course_reason"]') || {}).value || '';
      if (dept || number || name || reason) courses.push({dept, number, name, reason});
    });
  }
  if (courses.length) data.courses = courses;

  // Save to localStorage
  localStorage.setItem("introData", JSON.stringify(data));

  // Render the intro page
  try {
    // ensure displayName is present in the saved data
    const fd2 = new FormData(form);
    data.displayName = computeDisplayName(fd2);
  } catch (e) {}
  renderIntro(data);
});

function renderIntro(data) {
  data = data || {};
  // helper to create an element with optional class and text
  function el(tag, className, text) {
    const e = document.createElement(tag);
    if (className) e.className = className;
    if (text !== undefined) e.textContent = text;
    return e;
  }

  // build the preview into a document fragment first
  const frag = document.createDocumentFragment();

  // Header and acknowledgment
  // First line: Last, First M.
  const last = (data.lastName || '').toString().trim();
  const first = (data.firstName || '').toString().trim();
  const middle = (data.middleName || '').toString().trim();
  const middleInitial = middle ? (middle[0] + '.') : '';
  const line1 = last ? `${last}, ${first}${middleInitial ? ' ' + middleInitial : ''}` : `${first} ${middleInitial}`.trim();
  frag.appendChild(el('h2', 'name-line', line1 || ''));
  const metaP = document.createElement('p'); metaP.className = 'italic';
  const metaParts = [];
  if (data.email) metaParts.push(data.email);
  metaP.textContent = metaParts.join(' \u2022 ');
  frag.appendChild(metaP);
  frag.appendChild(el('p', 'italic', data.acknowledgment || ''));

  // display name as a prominent H3
  const displayLine = (function() {
    if (data.displayName && data.displayName.trim()) return data.displayName.trim();
    const parts = [];
    if (data.firstName) parts.push(data.firstName);
    if (data.middleName) parts.push((data.middleName.trim()[0] || '') + '.');
    if (data.preferredName) parts.push('"' + data.preferredName + '"');
    if (data.lastName) parts.push(data.lastName);
    return parts.filter(Boolean).join(' ');
  })();
  // If the computed displayLine already contains the mascot, replace that first occurrence
  // with the mascotDescriptor (if provided) so the mascot only appears once and the
  // descriptor is shown in the first position.
  let displayBase = displayLine || '';
  if (data.mascot && displayBase && displayBase.indexOf(data.mascot) !== -1) {
    const desc = (data.mascotDescriptor || '').toString().trim();
    if (desc) {
      // replace only the first occurrence
      displayBase = displayBase.replace(data.mascot, desc);
    } else {
      // remove the duplicated mascot occurrence to avoid repetition
      displayBase = displayBase.replace(data.mascot, '').replace(/\s*~\s*$/, '').trim();
    }
  }
  const finalDisplay = `${displayBase} ${data.mascot ? ' ~ ' + data.mascot : ''}`.trim();
  frag.appendChild(el('h3', 'display-name', finalDisplay));

  // image and caption in a centered figure
  // Prefer uploaded image data (Data URL) -> explicit imageUrl -> fallback sample/random
  const chosenImageSrc = data.imageData && data.imageData.trim() ? data.imageData.trim() : (data.imageUrl && data.imageUrl.trim() ? data.imageUrl.trim() : 'https://picsum.photos/300?random=1');
  if (chosenImageSrc || data.caption) {
    const fig = document.createElement('figure'); fig.className = 'profile-figure';
    if (chosenImageSrc) {
      const img = document.createElement('img'); img.src = chosenImageSrc; img.alt = 'Profile Picture'; img.onerror = function() { this.style.display = 'none'; }; img.className = 'profile-image'; fig.appendChild(img);
    }
    if (data.caption) { const fc = document.createElement('figcaption'); fc.className = 'italic'; fc.textContent = data.caption; fig.appendChild(fc); }
    frag.appendChild(fig);
  }
  frag.appendChild(el('p', null, data.personalStatement || ''));

  const list = document.createElement('ul');
  const addListItem = (label, value) => {
    const li = document.createElement('li');
    const strong = document.createElement('strong');
    strong.textContent = label;
    li.appendChild(strong);
    li.appendChild(document.createTextNode(' ' + (value || '')));
    list.appendChild(li);
  };

  addListItem('Personal Background:', data.personalBackground);
  addListItem('Professional Background:', data.professionalBackground);
  addListItem('Academic Background:', data.academicBackground);
  // legacy 'Primary Computer' removed; structured details rendered below when present

  const platform = data.computerPlatform || '';
  const os = data.computerOS || '';
  const location = data.workLocation || '';
  const backup = data.backupPlan || '';
  if (platform || os || location) {
    const parts = [];
    if (platform) parts.push(platform);
    if (os) parts.push(os);
    if (location) parts.push(`Location: ${location}`);
    // create primary computer li so backup plan can be nested below
    const li = document.createElement('li');
    const strong = document.createElement('strong'); strong.textContent = 'Primary Computer (details):';
    li.appendChild(strong);
    li.appendChild(document.createTextNode(' ' + parts.join(' — ')));
    list.appendChild(li);
  }

  // Render Backup Plan as a sibling list item (not nested under Primary Computer)
  if (backup) {
    const bLi = document.createElement('li');
    const bStrong = document.createElement('strong'); bStrong.textContent = 'Backup Plan:';
    bLi.appendChild(bStrong);
    bLi.appendChild(document.createTextNode(' ' + backup));
    list.appendChild(bLi);
  }

  // Courses: prefer the structured courses array if present
  if (data.courses && Array.isArray(data.courses) && data.courses.length) {
    const coursesLi = document.createElement('li');
    const coursesStrong = document.createElement('strong');
    coursesStrong.textContent = "Courses I\u2019m Taking & Why:";
    coursesLi.appendChild(coursesStrong);
    const coursesOl = document.createElement('ol');
    data.courses.forEach(c => {
      const cli = document.createElement('li');
      const title = `${c.dept || ''} ${c.number || ''} — ${c.name || ''}`.trim();
      const strong = document.createElement('strong'); strong.textContent = title + ':';
      cli.appendChild(strong);
      cli.appendChild(document.createTextNode(' ' + (c.reason || '')));
      coursesOl.appendChild(cli);
    });
    coursesLi.appendChild(coursesOl);
    list.appendChild(coursesLi);
  } else {
    const coursesLi = document.createElement('li');
    const coursesStrong = document.createElement('strong');
    coursesStrong.textContent = "Courses I\u2019m Taking & Why:";
    coursesLi.appendChild(coursesStrong);
    const coursesOl = document.createElement('ol');
    const course = (code, value) => {
      const cli = document.createElement('li');
      const strong = document.createElement('strong'); strong.textContent = code + ':';
      cli.appendChild(strong);
      cli.appendChild(document.createTextNode(' ' + (value || '')));
      coursesOl.appendChild(cli);
    };
    course('CRS101', data.crs101);
    course('CRS201', data.crs201);
    course('CRS330', data.crs330);
    coursesLi.appendChild(coursesOl);
    list.appendChild(coursesLi);
  }

  const rememberPieces = [];
  if (data.funnyRemember) rememberPieces.push(data.funnyRemember);
  if (data.funFact) rememberPieces.push(data.funFact);
  if (rememberPieces.length) addListItem('Remember me by:', rememberPieces.join(' — '));

  const additionalPieces = [];
  if (data.additionalInfo) additionalPieces.push(data.additionalInfo);
  if (data.otherNotes) additionalPieces.push(data.otherNotes);
  if (additionalPieces.length) addListItem("I'd Also Like to Share:", additionalPieces.join(' — '));

  // Backup plan is nested under Primary Computer (if present) to keep related info together

  frag.appendChild(list);

  if (data.quoteText || data.quoteAuthor) {
    const p = document.createElement('p');
    p.className = 'quote centered';
    p.textContent = `"${data.quoteText || ''}"`;
    frag.appendChild(p);
    if (data.quoteAuthor) {
      const authorDiv = document.createElement('div');
      authorDiv.className = 'quote-author italic centered';
      authorDiv.textContent = `– ${data.quoteAuthor}`;
      frag.appendChild(authorDiv);
    }
  }

  if (data.languages) {
    frag.appendChild(el('p', null, `Languages: ${data.languages}`));
  }
  // backup is included above as a separate list item when present

  // render to output container
  output.innerHTML = '';
  output.appendChild(frag);

  // populate JSON and HTML code areas if present
  const jsonArea = document.getElementById('jsonOutput');
  const htmlArea = document.getElementById('htmlOutput');
  try {
    if (jsonArea) jsonArea.value = JSON.stringify(data, null, 2);
  } catch (err) {
    if (jsonArea) jsonArea.value = String(data);
  }
  if (htmlArea) {
    // Pretty-print the DOM inside `output` into a readable HTML string.
    const voidElements = new Set(['area','base','br','col','embed','hr','img','input','link','meta','param','source','track','wbr']);

    function escapeAttr(s) {
      return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    function escapeText(s) {
      return String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }

    function serialize(node, indent) {
      indent = indent || '';
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tag = node.tagName.toLowerCase();
        const attrs = Array.from(node.attributes || []).map(a => `${a.name}="${escapeAttr(a.value)}"`).join(' ');
        const open = attrs ? `<${tag} ${attrs}>` : `<${tag}>`;
        const children = Array.from(node.childNodes || []).filter(n => !(n.nodeType === Node.TEXT_NODE && String(n.nodeValue).trim() === ''));

        // Void element (self-closing)
        if (voidElements.has(tag) && children.length === 0) return indent + open.replace(/>$/, ' />');

        // If single text child, render on one line
        if (children.length === 1 && children[0].nodeType === Node.TEXT_NODE) {
          const text = String(children[0].nodeValue || '');
          return indent + open + escapeText(text.trim()) + `</${tag}>`;
        }

        // Multi-line element
        const lines = [indent + open];
        for (const child of children) {
          if (child.nodeType === Node.TEXT_NODE) {
            const txt = String(child.nodeValue || '').trim();
            if (txt) lines.push(indent + '  ' + escapeText(txt));
          } else {
            lines.push(serialize(child, indent + '  '));
          }
        }
        lines.push(indent + `</${tag}>`);
        return lines.join('\n');
      } else if (node.nodeType === Node.TEXT_NODE) {
        const t = String(node.nodeValue || '').trim();
        return t ? indent + escapeText(t) : '';
      } else if (node.nodeType === Node.COMMENT_NODE) {
        return indent + `<!-- ${String(node.nodeValue || '').trim()} -->`;
      }
      return '';
    }

    function formatContainer(container) {
      const parts = [];
      for (const child of Array.from(container.childNodes)) {
        const s = serialize(child, '');
        if (s) parts.push(s);
      }
      return parts.join('\n');
    }

    try {
      htmlArea.value = formatContainer(output);
    } catch (err) {
      // Fallback to raw innerHTML if anything goes wrong
      htmlArea.value = output.innerHTML;
    }
  }
}
